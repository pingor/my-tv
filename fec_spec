1	概述
在互联网电视流媒体传输层面，丢包会直接影响了视频音频的解码，引起视频停顿或马赛克。FEC（Forward Error Correction）前向纠错技术被广泛利用于视频直播组播模式，该技术可以通过冗余编码实现组播丢包恢复。
2	FEC技术
FEC（Forward Error Correction）前向纠错是一种通过在信息源增加冗余信息实现丢包恢复的措施。在IP网络里，数据报文的正确性已经由网络层保证，如果出现传输错误，设备、网卡会自动丢弃。所以，这里的FEC应用不是纠错，而是丢包恢复（或者说，遗失数据报文的位置是可知的）。FEC的数据处理流程大致如下：
1.	媒体服务器对原始媒体内容进行前向纠错编码，生成冗余信息；
2.	原始媒体数据与FEC冗余数据发送到客户端，可能存在丢包；
3.	终端根据收到的数据进行FEC解码，恢复出丢失报文的完整内容；
4.	FEC无需反馈的机制特点使其适用于视频组播应用。
3	总体流程
【主要流程说明】：
1、	牌照方头端提供频道直播源；
2、	视频平台接收牌照方头端的频道直播源，创建频道，配置频道FEC功能和FEC端口，对直播源码流进行处理，生成RTP组播码流和FEC码流；
3、	视频平台对外发送频道组播码流和FEC码流；
4、	CDN 通知EPG每个频道的播放URL；
5、	用户在机顶盒上观看频道时，牌照方APK从牌照方EPG获取频道播放URL信息；
6、	牌照方APK调用机顶盒的MediaPlayer接口将频道播放URL传给机顶盒播放器播放；
7、	机顶盒播放器解析频道播放URL，加入组播组，请求频道RTP组播码流和FEC码流；
8、	组播复制点返回频道RTP组播码流和FEC码流；
9、	机顶盒播放器进行FEC解码播放处理。

4	FEC端口配置
频道在视频平台创建之后，平台将频道播放URL提供给牌照方EPG，在原频道直播URL中增加FEC端口信息ChannelFECPort。
ChannelFECPort 	频道支持FEC的端口号，若该频道支持FEC则填写端口号，否则为空	int 	16 	M 

牌照方下发给机顶盒的支持FEC的频道组播播放URL样例：
rtp://225.56.104.1:8400?ChannelFECPort=8402
若该频道支持FEC则填写ChannelFECPort参数，否则为空。如果频道URL中没有ChannelFECPort参数则认为该频道不支持FEC。FEC流采用带外承载方式，与组播组同一个IP地址，以UDP端口区分原始组播流和FEC流，样例中8400为组播流的端口，8402为FEC码流的端口。
牌照方APK调用机顶盒的MediaPlayer接口将组播URL传给机顶盒播放器播放。机顶盒做FEC的相关解码整合播放。

5	FEC技术要求
5.1	基本要求
1.	任何终端和平台之间可互通；
2.	FEC算法应能够满足任意位置随机丢包可恢复的要求，FEC冗余度不超过5%，对于1%的随机丢包至少要达到99%以上的恢复成功率，对于2%的随机丢包至少要达到95%以上的恢复成功率；
3.	增加的FEC冗余报文不能影响码流的MDI:DF值，组播组“原始码流+FEC码流”的MDI:DF值，标清要求<100ms，高清要求<20ms；
4.	服务侧增加FEC功能不应增加发流时延，应能实现一边发流，一边进行FEC编码及发FEC流；
5.	机顶盒增加FEC功能后，不应额外叠加组播切换时延。例如，如果没有FEC时，组播的切换时延是500ms，那么，增加FEC后，组播切换时延仍为500ms。为保障切换时延不增加，切换瞬间可不纠错。
5.2	FEC流的承载
采用带外承载方式，与组播组同一个IP地址，以UDP端口区分原始组播流和FEC流，默认端口为组播端口-1，如机顶盒获取的频道列表信息中有指定的FEC端口，则必须采用指定端口。
5.3	FEC帧格式
FEC帧格式：RTP头+FEC结构。
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         RTP 头                                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         FEC 结构                              |
   |                                                                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
RTP头要求
FEC冗余报文RTP头的要求如下：
 
该格式严格遵循RFC3550的规定，如果描述中有和RFC3550冲突的地方，请以RFC3550为准， 各个字段的意义和规范要求如下：
	V=2
	P=0
	X=0
	CC=0	
	M=0
	PT=127
	Sequence number ，FEC报文单独编号
	Timestamp =0
	SSRC = 关联源RTP的SSRC
5.4	FEC结构
1.	FEC数据结构描述
FEC_DATA_STRUCT
{
UINT16 rtp_begin_seq;    //源码流FEC编码起始RTP序号
UINT16 rtp_end_seq;      //源码流FEC编码结束RTP序号
UINT8 redund_num;      //FEC报文数
   UINT8 redund_idx;       //FEC报文索引序号，从0开始
   UINT16 fec_len;            //FEC荷载字节数
   UINT16 rtp_len;            //被编码RTP报文的最大长度，字节数。包括RTP包头+载荷，一般为12+1316byte，如扩展rtp包头长度增加16个。如果被编码RTP报文不足长度，则编码时对该RTP用TS空包填充（注：发送流保持不变），TS空包参考ISO13818-1规范（要求除了PID=1FFF外，其他位都填0）。这样，被恢复的数据包长度统一。
  UINT16 rsv;            //备用，全填充为0
UINT8   fec_data[x];     //fec数据，对rtp报文进行fec编码（注：是原始rtp报文，不是ts报文。）
}
2.	FEC数据封装
0              1             2              3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        rtp_begin_seq   |        rtp_end_seq       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| redund_num | redund_idx |           fec_len         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         rtp_len        |            rsv           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_data                   |
|                        . . . .                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
5.5	同步方式
FEC冗余数据结构里面包含了RTP起止序号，根据这个信息就可以实现冗余数据与原始数据之间的同步。服务端增加FEC功能后，对原始RTP数据仍应线速转发，不应有延时，FEC数据在本组RTP数据都转发完毕后才编码出来并发送出去的。在100+3模式下的应用举例如下图所示：
考虑到降低码流的突发，这个冗余数据报文应当与下一组RTP数据交叉平滑发出。组播组“fec冗余+原始RTP码流”平均速率应不超过原始码流速率*（1+冗余率），并要求“FEC冗余+原始RTP码流”标清MDI:DF<100ms，高清MDI:DF<20ms。
    FEC冗余率和编码组的大小在服务端应可设置。FEC冗余数据的个数一般不超过5%，FEC编码组一般不超过100个RTP报文。
5.6	FEC算法
5.6.1	基本要求
FEC采用里得所罗门算法，参考RFC5510：《Reed-Solomon Forward Error Correction (FEC) Schemes》，要求丢包恢复能力与丢包的位置无关。FEC算法不对RTP序号交织，按RTP顺序形成FEC冗余报文。
FEC算法模块在平台、机顶盒中的位置：
 
5.6.2	FEC解码API定义
为满足FEC算法的互通，为平台厂商和机顶盒厂商提供FEC算法代码，具体接口如下：
1.	fec_encode编码接口
函数原型
int fec_encode(int data_pkt_num, int fec_pkt_num, int data_len, char *data[], char *fec_data[]);
参数说明
data_pkt_num: 一个分组内数据报文的个数
fec_pkt_num: 一个分组内冗余报文的个数
data_len:参与编解码的数据字节长度
data:原始数据向量组
fec_data:输出的冗余数据向量组
返回值
int:成功返回0，否则返回错误码
备注
对于数据向量要预留足够内存空间，避免访问越界。
2.	fec_decode解码接口
函数原型
int fec_decode(int data_pkt_num, int fec_pkt_num, int data_len, char *data[], char *fec_data[], int lost_map[]);
参数说明
data_pkt_num: 一个分组内数据报文的个数
fec_pkt_num: 一个分组内冗余报文的个数
data_len:参与编解码的数据字节长度
fec_data:冗余数据向量组，丢失的报文以全零填充
lost_map:报文丢失映射表，0表示报文丢失，1表示报文收到，前N个表示原始数据报，后M个表示冗余数据报
返回值
int:成功返回0，否则返回错误码
备注
对于原始数据报无丢失的情况此接口应当直接返回成功，不作处理。
